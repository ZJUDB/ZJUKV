// Copyright (c) 2012 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.

#include <cmath>

#include "leveldb/filter_policy.h"

#include "leveldb/slice.h"
#include "util/hash.h"

#include "util/murmur.h"

namespace leveldb {

namespace {
static uint32_t BloomHash(const Slice& key) {
  return Hash(key.data(), key.size(), 0xbc9f1d34);
}

class BloomFilterPolicy : public FilterPolicy {
 private:
  size_t bits_per_key_;
  size_t k_;

 public:
  explicit BloomFilterPolicy(int bits_per_key)
      : bits_per_key_(bits_per_key) {
    // We intentionally round down to reduce probing cost a little bit
    k_ = static_cast<size_t>(bits_per_key * 0.69);  // 0.69 =~ ln(2)
    if (k_ < 1) k_ = 1;
    if (k_ > 30) k_ = 30;
  }

  virtual const char* Name() const {
    return "leveldb.BuiltinBloomFilter2";
  }

  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
    // Compute bloom filter size (in both bits and bytes)
    size_t bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = dst->size();
    dst->resize(init_size + bytes, 0);
    dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
    char* array = &(*dst)[init_size];
    for (int i = 0; i < n; i++) {
      // Use double-hashing to generate a sequence of hash values.
      // See analysis in [Kirsch,Mitzenmacher 2006].
      uint32_t h = BloomHash(keys[i]);
      const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
      for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += delta;
      }
    }
  }

  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }

    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }
    return true;
  }
};
}

const FilterPolicy* NewBloomFilterPolicy(int bits_per_key) {
  return new BloomFilterPolicy(bits_per_key);
}


static uint64_t BloomHashMurmur(const Slice& key) {
  return MurmurHash64A(key.data(), key.size(), 0xdeadbeef12345678ULL);
}

template <typename Key>
class bloom1
{
public:
    using key_type = Key;
    typedef uint64_t word_t;
    static constexpr int bits_per_byte = 8;
    static constexpr int bytes_per_word = 8;
    static constexpr int bits_per_word = bits_per_byte * bytes_per_word;
    static constexpr int member_bit_width = 6;
    static constexpr int member_bit_mask = (1 << member_bit_width) - 1;
    static constexpr int word_hash_bits = 24;
    static constexpr int word_hash_bits_mask = (1ULL << word_hash_bits) - 1;
    static constexpr int k = 3;
    static constexpr int member_hash_bits = std::ceil(k * member_bit_width);
    static constexpr uint64_t hash_seed = 0xdeadbeef12345678ULL;
    bloom1(int entries, double fp_rate)
    {
      this->entries = entries;
      error = fp_rate;

      double num = log(error);
      double denom = 0.480453013918201; // ln(2)^2
      double bpe = -(num / denom);

      double dentries = (double)entries;
      bits_m = (int)(dentries * bpe);

      if (bits_m % bits_per_byte)
      {
        bytes_n = (bits_m / bits_per_byte) + 1;
      }
      else
      {
        bytes_n = bits_m / bits_per_byte;
      }

      if (bytes_n % bytes_per_word)
      {
        words_l = (bytes_n / bytes_per_word) + 1;
      }
      else
      {
        words_l = bytes_n / bytes_per_word;
      }
      hash_bits = word_hash_bits + member_hash_bits;
      // assert(hash_bits <= bits_per_word);
      words = (word_t*)calloc(words_l, sizeof(word_t));
    }

    ~bloom1() { free(words); }

    uint64_t make_word_mask(uint64_t h, int &word_off)
    {
      uint64_t old_h = h;
      uint64_t word_mask = 0;
      word_off = (h & word_hash_bits_mask) % words_l;
      h >>= word_hash_bits;
      int bits_left = member_hash_bits;
      int h_bits = bits_per_word - word_hash_bits;
      while (bits_left)
      {
        if (h_bits < member_bit_width)
        {
          h = MurmurHash64A(&old_h, sizeof(old_h), hash_seed);
          old_h = h;
          h_bits = bits_per_word;
        }
        int member_off = h & member_bit_mask;
        word_mask |= 1ULL << member_off;
        h >>= member_bit_width;
        h_bits -= member_bit_width;
        bits_left -= member_bit_width;
      }
      return word_mask;
    }

    template<class HashFunc>
    void insert(const key_type &key, HashFunc hash_func)
    {
      uint64_t h = hash_func(key);
      int word_off = -1;
      uint64_t word_mask = make_word_mask(h, word_off);
      words[word_off] |= word_mask;
    }

    template<class HashFunc>
    bool check(const key_type &key, HashFunc hash_func)
    {
      uint64_t h = hash_func(key);
      int word_off = -1;
      uint64_t word_mask = make_word_mask(h, word_off);
      return (words[word_off] & word_mask) == word_mask;
    }

    int entries;
    int bits_m;
    int bytes_n;
    int words_l;
    int hash_bits;
    word_t *words;
    double error;
};

class DynamicFilterBloom :public DynamicFilter {
public:
    DynamicFilterBloom(int entries, double fp_rate): b(entries, fp_rate) {}

    ~DynamicFilterBloom() {}

    // Add a key to this filter
    void Add(const Slice key)  {
      b.insert(key, BloomHashMurmur);
    }

    // Check if the key is possibly in the filter
    bool KeyMayMatch(const Slice& key) {
      return b.check(key, BloomHashMurmur);
    }
private:
    bloom1<Slice> b;
};

DynamicFilter* NewDynamicFilterBloom(int entries, double fp_rate) {
  return new DynamicFilterBloom(entries, fp_rate);
}

}  // namespace leveldb
